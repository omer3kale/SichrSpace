# ============================================================
# SichrPlace — Feature Descriptor: Email Verification
# Template: feature_spec.ftl + controller_service_design.ftl
#            + migration_plan.ftl
# ============================================================

# ── Feature identity ──
featureId:        "auth_email_verification"
featureName:      "Email Verification"
phase:            "Phase 1"
priority:         "P0 — Critical Path"
effort:           "4–6 hours"
author:           "Omer Kale"
date:             "2026-02-20"

# ── Legacy references ──
legacyRouteFiles:
  - "routes/auth.js"
legacyServiceFiles:
  - "services/emailService.js"
legacyEndpoints:
  - method: "GET"
    path: "/api/auth/verify-email/:token"
    description: "Verify email address via signed JWT token"
    status: "IMPLEMENTED"
legacyDescription: |
  After registration the old backend sends a verification email containing a
  signed JWT as a URL parameter.  The GET endpoint decodes the token, marks
  the user as verified in Supabase (`email_verified = true`), and redirects
  to the login page.  If the token is invalid or expired, an error page is
  shown.  The email is sent via Gmail SMTP through the `emailService`.

# ── Spring Boot design ──
springControllers:
  - "UserController.java"
springServices:
  - "UserService.java / UserServiceImpl.java"
  - "EmailService.java / EmailServiceImpl.java"
springEntities:
  - "User.java (add emailVerified, verificationToken fields)"
dbTables:
  - "users (ALTER — add email_verified BIT, verification_token NVARCHAR)"

# ── Design doc placeholders ──
controllerName:   "UserController"
serviceName:      "UserService"
serviceImplName:  "UserServiceImpl"
repositoryName:   "UserRepository"
entityName:       "User"
basePath:         "/api/auth"

dtoNames:
  - "VerifyEmailResponseDto"

methods:
  - httpMethod: "GET"
    path: "/api/auth/verify-email/{token}"
    summary: "Verify email address via token URL"
    roles: "— (public)"
    requestBody: ""
    responseBody: "VerifyEmailResponseDto"
    notes: "Token is a UUID stored on the user row. Single-use, expires after 24 h."
    statusCodes: "200 OK, 400 Bad Request (invalid), 410 Gone (expired)"
  - httpMethod: "POST"
    path: "/api/auth/resend-verification"
    summary: "Resend verification email"
    roles: "Bearer (authenticated, unverified users)"
    requestBody: ""
    responseBody: "{ message: string }"
    notes: "Rate-limited to 1 per minute. Generates a new token, invalidates old."
    statusCodes: "200 OK, 429 Too Many Requests"

securityRoles:
  - role: "Anonymous"
    actions: "Verify email via GET token link"
  - role: "Authenticated (unverified)"
    actions: "Resend verification email"
  - role: "ADMIN"
    actions: "—"

serviceDependencies:
  - name: "EmailService"
    reason: "Send verification email with token link"
  - name: "UserRepository"
    reason: "Find user by verification token, update emailVerified flag"

errorHandling:
  - scenario: "Token not found in DB"
    exception: "ResourceNotFoundException"
    httpStatus: "400 Bad Request"
  - scenario: "Token expired (>24 h)"
    exception: "TokenExpiredException"
    httpStatus: "410 Gone"
  - scenario: "User already verified"
    exception: "—"
    httpStatus: "200 OK (idempotent, no error)"
  - scenario: "Resend too soon (<1 min)"
    exception: "RateLimitException"
    httpStatus: "429 Too Many Requests"

# ── Endpoints (new) ──
endpoints:
  - method: "GET"
    path: "/api/auth/verify-email/{token}"
    auth: "—"
    description: "Verify email address via token"
  - method: "POST"
    path: "/api/auth/resend-verification"
    auth: "Bearer"
    description: "Resend verification email"

# ── Schema ──
migrationId: "V007__user_email_verification"
ddlSketch: |
  -- V007: Add email verification fields to users table
  IF NOT EXISTS (
      SELECT 1 FROM sys.columns
      WHERE object_id = OBJECT_ID('dbo.users') AND name = 'email_verified'
  )
  BEGIN
      ALTER TABLE dbo.users
          ADD email_verified        BIT           NOT NULL DEFAULT 0;
  END;
  GO

  IF NOT EXISTS (
      SELECT 1 FROM sys.columns
      WHERE object_id = OBJECT_ID('dbo.users') AND name = 'verification_token'
  )
  BEGIN
      ALTER TABLE dbo.users
          ADD verification_token    NVARCHAR(512) NULL;
  END;
  GO

  IF NOT EXISTS (
      SELECT 1 FROM sys.columns
      WHERE object_id = OBJECT_ID('dbo.users') AND name = 'verification_token_expires_at'
  )
  BEGIN
      ALTER TABLE dbo.users
          ADD verification_token_expires_at DATETIME2 NULL;
  END;
  GO

  -- Index for token lookup
  IF NOT EXISTS (SELECT 1 FROM sys.indexes WHERE name = 'IX_users_verification_token')
  BEGIN
      CREATE INDEX IX_users_verification_token
          ON dbo.users (verification_token)
          WHERE verification_token IS NOT NULL;
  END;
  GO
relationships: |
  No new relationships — column additions to existing `users` table.
  The `verification_token` is a UUID string, not a FK.

# ── Quality ──
securityConsiderations: |
  - **Single-use tokens:** Set `verification_token` to NULL after successful
    verification.  Prevents replay attacks.
  - **Token expiry:** `verification_token_expires_at` must be checked.  Default
    TTL = 24 hours.  Expired tokens → 410 Gone.
  - **Rate limiting:** The resend endpoint must be rate-limited (1 per minute per
    user) to prevent email flooding.
  - **No PII in URL:** The token is an opaque UUID, not a JWT containing user data.
  - **Login gate:** After this feature, `POST /api/auth/login` should return 403 if
    `email_verified = false`, with a message prompting the user to verify.

edgeCases:
  - "Token already used → 400 Bad Request with message 'Token is invalid or has already been used.'"
  - "Token expired (>24 h) → 410 Gone with message 'Verification token has expired. Please request a new one.'"
  - "User already verified → 200 OK (idempotent, return { verified: true })."
  - "Non-existent token → 400 Bad Request."
  - "Resend before 1 minute elapsed → 429 Too Many Requests."
  - "Resend for already-verified user → 400 Bad Request with 'Email already verified.'"

acceptanceCriteria:
  - "POST /api/auth/register sends a verification email with a unique UUID token."
  - "GET /api/auth/verify-email/{token} marks the user as email_verified = true."
  - "POST /api/auth/login returns 403 if email_verified = false."
  - "Expired tokens (>24 h) are rejected with 410 Gone."
  - "Already-used tokens are rejected with 400."
  - "POST /api/auth/resend-verification generates a new token and sends a new email."
  - "Resend is rate-limited to 1 request per minute per user."
  - "DataSeeder creates users with email_verified = true (existing seed data unaffected)."

testingStrategy:
  - layer: "Unit"
    tool: "JUnit 5 + Mockito"
    description: "Service logic — token generation, expiry check, idempotent verify, rate limit"
  - layer: "Integration"
    tool: "@SpringBootTest + H2"
    description: "Full flow — register → check email_verified=false → verify → login succeeds"
  - layer: "API"
    tool: "MockMvc"
    description: "Endpoint contracts — 200/400/410/429 status codes, response bodies"
  - layer: "Smoke"
    tool: "MssqlProfileSmokeTest"
    description: "Verify email_verified column exists and is queryable"

dependencies:
  - "spring-boot-starter-mail (Jakarta Mail)"
  - "FreeMarker or Thymeleaf for email body rendering"

openQuestions:
  - "Use FreeMarker or Thymeleaf for email body templates?  FreeMarker is already in the project for this roadmap system."
  - "Should verification redirect to a frontend URL or return JSON?  JSON is more API-friendly; frontend can handle the redirect."

# ── Migration plan extras ──
changesSummary: |
  Adds three columns to the existing `users` table to support email verification:
  `email_verified` (BIT, default 0), `verification_token` (NVARCHAR(512), nullable),
  and `verification_token_expires_at` (DATETIME2, nullable).  Also adds a filtered
  index on `verification_token` for fast lookups.

tablesTouched:
  - name: "users"
    action: "ALTER"
    details: "Add email_verified, verification_token, verification_token_expires_at columns + filtered index"

backfillSteps:
  - "Set email_verified = 1 for all existing seed users (they are pre-verified)."
  - "No verification_token needed for existing users."

rollbackSteps:
  - "DROP INDEX IX_users_verification_token ON dbo.users;"
  - "ALTER TABLE dbo.users DROP COLUMN verification_token_expires_at;"
  - "ALTER TABLE dbo.users DROP COLUMN verification_token;"
  - "ALTER TABLE dbo.users DROP COLUMN email_verified;"

verificationSteps:
  - "SELECT email_verified, verification_token FROM dbo.users WHERE username = 'alice'; — should show 1, NULL"
  - "SELECT name FROM sys.indexes WHERE object_id = OBJECT_ID('dbo.users') AND name = 'IX_users_verification_token';"
  - "INSERT a test row with email_verified = 0, verification_token = 'test-token' — confirm index is used."

seedSql: |
  -- Backfill: mark all existing seed users as verified
  UPDATE dbo.users SET email_verified = 1 WHERE email_verified = 0;

migrationDependencies:
  - "V001__initial_schema.sql"
  - "V002__seed_data.sql"

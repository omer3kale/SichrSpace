plugins {
    id 'java'
    id 'jacoco'
    id 'org.springframework.boot' version '3.2.2'
    id 'io.spring.dependency-management' version '1.1.4'
}

group = 'com.sichrplace'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '21'
    targetCompatibility = '21'
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'
    
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0'
    
    runtimeOnly 'com.microsoft.sqlserver:mssql-jdbc'
    runtimeOnly 'org.postgresql:postgresql'
    
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'com.h2database:h2'
}

tasks.named('test') {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// ── JaCoCo ──────────────────────────────────────────────────────────
jacoco {
    toolVersion = '0.8.12'
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required  = true
        html.required = true
        csv.required  = false
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    violationRules {
        rule {
            limit {
                counter = 'INSTRUCTION'
                minimum = 0.12   // Raised from 3% → 12% (v1.3.0, Feb 2026)
            }
        }
    }
}

// Convenience alias: ./gradlew testWithCoverage
tasks.register('testWithCoverage') {
    group = 'verification'
    description = 'Runs tests, generates JaCoCo report, and verifies global coverage.'
    dependsOn test, jacocoTestReport, jacocoTestCoverageVerification
}

// ── COCO checker ────────────────────────────────────────────────────
// Reads per-package thresholds from docs/coco_rules.yml and verifies
// them against the JaCoCo XML report.
tasks.register('checkCoco') {
    group = 'verification'
    description = 'Checks per-package code-coverage objectives (COCO rules).'
    dependsOn jacocoTestReport

    doLast {
        def rulesFile = file("${projectDir}/docs/coco_rules.yml")
        if (!rulesFile.exists()) {
            throw new GradleException("docs/coco_rules.yml not found — cannot check COCO rules.")
        }

        def reportFile = file("${buildDir}/reports/jacoco/test/jacocoTestReport.xml")
        if (!reportFile.exists()) {
            throw new GradleException(
                "JaCoCo XML report not found. Run ./gradlew test jacocoTestReport first.")
        }

        // ─── Parse coco_rules.yml (simple line-based parsing) ───
        def rules = [:]
        def overallTarget = 3
        def currentPackage = null
        def inPackages = false
        rulesFile.eachLine { line ->
            def trimmed = line.trim()
            if (trimmed.startsWith('packages:')) { inPackages = true; return }
            // Strip inline YAML comments: "target: 4  # comment" → "4"
            def stripComment = { String s -> s.replaceAll('#.*', '').trim() }
            if (!inPackages && trimmed.startsWith('target:')) {
                def val = stripComment(trimmed.replaceAll('target:\\s*', ''))
                if (val) overallTarget = val as int
            }
            // Package names are at exactly 2-space indent: "  service:"
            // NOT 4-space sub-keys like "    target:" or "    aspiration:"
            if (inPackages && line ==~ /^  [a-z]\w*:\s*$/) {
                currentPackage = trimmed.replace(':', '').trim()
            }
            if (inPackages && currentPackage != null && trimmed.startsWith('target:')) {
                def val = stripComment(trimmed.replaceAll('target:\\s*', ''))
                if (val) {
                    rules[currentPackage] = val as int
                    currentPackage = null
                }
            }
        }

        // ─── Parse JaCoCo XML report ───
        def parser = new XmlSlurper()
        parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
        def xml = parser.parse(reportFile)
        def pkgBasePrefix = 'com/sichrplace/backend/'

        def failures = []
        def results = []

        // Per-package checks
        xml.package.each { pkg ->
            def pkgName = pkg.@name.toString()
            if (!pkgName.startsWith(pkgBasePrefix)) return

            def subPkg = pkgName.replace(pkgBasePrefix, '')
            def threshold = rules[subPkg]
            if (threshold == null) return

            def instrCounter = pkg.counter.find { it.@type == 'INSTRUCTION' }
            if (instrCounter == null) return

            def missedStr  = instrCounter.@missed.toString()
            def coveredStr = instrCounter.@covered.toString()
            if (!missedStr || !coveredStr) return
            def missed  = missedStr as int
            def covered = coveredStr as int
            def total   = missed + covered
            def pct     = total > 0 ? ((covered * 100.0) / total).round(1) : 0.0

            def pass = pct >= threshold
            results << [pkg: subPkg, pct: pct, target: threshold, pass: pass]
            if (!pass) {
                failures << "${subPkg}: ${pct}% < ${threshold}%"
            }
        }

        // Overall check
        def overallInstr = xml.counter.find { it.@type == 'INSTRUCTION' }
        if (overallInstr) {
            def missedStr  = overallInstr.@missed.toString()
            def coveredStr = overallInstr.@covered.toString()
            if (missedStr && coveredStr) {
                def missed  = missedStr as int
                def covered = coveredStr as int
                def total   = missed + covered
                def pct     = total > 0 ? ((covered * 100.0) / total).round(1) : 0.0
                results << [pkg: 'OVERALL', pct: pct, target: overallTarget, pass: pct >= overallTarget]
                if (pct < overallTarget) {
                    failures << "OVERALL: ${pct}% < ${overallTarget}%"
                }
            }
        }

        // Print summary table
        println "\n╔══════════════════════════════════════════════════════════╗"
        println "║           COCO — Code Coverage Objectives               ║"
        println "╠══════════════════════════════════════════════════════════╣"
        results.each { r ->
            def status = r.pass ? '✓' : '✗'
            printf("║ %s %-20s  %5.1f%% / %3d%%                   ║%n", status, r.pkg, r.pct, r.target)
        }
        println "╚══════════════════════════════════════════════════════════╝"

        if (failures) {
            throw new GradleException("COCO check FAILED:\n  " + failures.join('\n  '))
        } else {
            println "✓ All COCO rules passed."
        }
    }
}

// ── Secrets scanner ─────────────────────────────────────────────────
// Scans source and config files for hardcoded secrets.
tasks.register('secretsCheck') {
    group = 'verification'
    description = 'Scans for hardcoded secrets in source and config files.'

    doLast {
        def patterns = [
            ~/(?i)(password|passwd|pwd)\s*[:=]\s*['"]?[A-Za-z0-9!@#%^&*]{6,}/,
            ~/(?i)(secret|api[_-]?key|auth[_-]?token)\s*[:=]\s*['"]?[A-Za-z0-9!@#%^&*_\-]{8,}/,
            ~/AKIA[0-9A-Z]{16}/,                     // AWS access key
            ~/-----BEGIN (RSA |EC |DSA )?PRIVATE KEY-----/,
            ~/(?i)bearer\s+[A-Za-z0-9\-._~+\/]+=*/,  // Bearer tokens
        ]

        // Patterns that are acceptable (test files, env-var placeholders, comments, docs)
        def allowPatterns = [
            ~/[$][{][A-Z_]+:/,     // Spring env-var placeholder ${VAR:default}
            ~/password123/,         // Seed data test password
            ~/changeme/,            // Documented placeholder
            ~/test-secret/,         // Test-profile secret
            ~/application-test/,    // Test config file
            ~/[$]env:/,             // PowerShell env-var examples
            ~/export\s+[A-Z_]+=\s*/,// Bash export examples
            ~/JWT_SECRET=/,         // Env-var assignment examples in docs
            ~/MSSQL_SA_PASSWORD=/,  // Docker env-var examples
            ~/LOCAL_DB_PASS=/,      // Env-var setup instructions
            ~/Bearer token/,        // Documentation describing auth
            ~/secret:\s*MyReal/,    // Intentional "bad example" in lab exercises
            ~/dev-only-/,           // Documented dev-only placeholder
            ~/local-dev-secret/,    // Documented local dev placeholder
            ~/not-for-production/,  // Documented non-production warning
        ]

        def scanDirs = [
            file("${projectDir}/src"),
        ]
        // Only scan code/config files — documentation (.md) is excluded
        // since it contains intentional examples and teaching content.
        def extensions = ['java', 'yml', 'yaml', 'properties', 'xml', 'json', 'ftl'] as Set

        def violations = []

        scanDirs.each { dir ->
            if (!dir.exists()) return
            dir.eachFileRecurse { f ->
                if (f.isDirectory()) return
                def ext = f.name.contains('.') ? f.name.substring(f.name.lastIndexOf('.') + 1) : ''
                if (!(ext in extensions)) return

                f.eachLine { line, lineNum ->
                    def trimmed = line.trim()
                    if (trimmed.startsWith('#') || trimmed.startsWith('//') || trimmed.startsWith('*')) return

                    patterns.each { pattern ->
                        if (line =~ pattern) {
                            def allowed = allowPatterns.any { ap -> line =~ ap }
                            if (!allowed) {
                                violations << "${f.absolutePath}:${lineNum}: ${trimmed.take(80)}"
                            }
                        }
                    }
                }
            }
        }

        if (violations) {
            println "\n⚠  Potential hardcoded secrets found:"
            violations.each { println "  ${it}" }
            throw new GradleException(
                "secretsCheck FAILED — ${violations.size()} potential secret(s) found.\n" +
                "Replace with environment-variable placeholders (\${VAR:default}).\n" +
                "See docs/SECURITY_AND_SECRETS.md for guidance.")
        } else {
            println "✓ No hardcoded secrets detected."
        }
    }
}

springBoot {
    mainClass = 'com.sichrplace.backend.SichrPlaceBackendApplication'
}
